{"ast":null,"code":"import _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport React from 'react';\nimport { PropTypes, Component } from '../../../libs';\nimport { toDate, getFirstDayOfMonth, getDayCountOfMonth, getWeekNumber, getStartDateOfMonth, DAY_DURATION, SELECTION_MODES, deconstructDate, hasClass, getOffsetToWeekOrigin } from '../utils';\nimport Locale from '../../locale';\n\nfunction isFunction(func) {\n  return typeof func === 'function';\n}\n\nvar clearHours = function clearHours(time) {\n  var cloneDate = new Date(time);\n  cloneDate.setHours(0, 0, 0, 0);\n  return cloneDate.getTime();\n};\n\nvar _WEEKS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\n\nvar DateTable = function (_Component) {\n  _inherits(DateTable, _Component);\n\n  function DateTable(props) {\n    _classCallCheck(this, DateTable);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    _this.state = {\n      tableRows: [[], [], [], [], [], []]\n    };\n    return _this;\n  }\n\n  DateTable.prototype.WEEKS = function WEEKS() {\n    // 0-6\n    var week = this.getOffsetWeek();\n    return [].concat(_WEEKS.slice(week), _WEEKS.slice(0, week));\n  };\n\n  DateTable.prototype.getOffsetWeek = function getOffsetWeek() {\n    return this.props.firstDayOfWeek % 7;\n  };\n\n  DateTable.prototype.getStartDate = function getStartDate() {\n    var ds = deconstructDate(this.props.date);\n    return getStartDateOfMonth(ds.year, ds.month, this.getOffsetWeek());\n  };\n\n  DateTable.prototype.getRows = function getRows() {\n    var _props = this.props,\n        date = _props.date,\n        disabledDate = _props.disabledDate,\n        showWeekNumber = _props.showWeekNumber,\n        minDate = _props.minDate,\n        maxDate = _props.maxDate,\n        selectionMode = _props.selectionMode,\n        firstDayOfWeek = _props.firstDayOfWeek;\n    var tableRows = this.state.tableRows;\n    var ndate = new Date(date.getTime());\n    var day = getFirstDayOfMonth(ndate); // day of first day\n\n    var dateCountOfMonth = getDayCountOfMonth(ndate.getFullYear(), ndate.getMonth()); // dates count in december is always 31, so offset year is not neccessary\n\n    var dateCountOfLastMonth = getDayCountOfMonth(ndate.getFullYear(), ndate.getMonth() === 0 ? 11 : ndate.getMonth() - 1);\n    var offsetDaysToWeekOrigin = getOffsetToWeekOrigin(day, firstDayOfWeek); //tableRows: [ [], [], [], [], [], [] ]\n\n    var rows = tableRows;\n    var count = 1;\n    var firstDayPosition = void 0;\n    var startDate = this.getStartDate();\n    var now = clearHours(new Date());\n\n    for (var i = 0; i < 6; i++) {\n      // rows\n      var row = rows[i];\n      /*\n      cell: {\n        type: string, one of 'week' | 'normal'\n        text: String,\n        row: number,  row index,\n        column: number, column index;\n        inRange: boolean,\n        start: boolean,\n        end: boolean,\n        disabled: boolean\n      }\n      */\n\n      if (showWeekNumber) {\n        //prepend week info to the head of each row array\n        if (!row[0]) {\n          row[0] = {\n            type: 'week',\n            text: getWeekNumber(new Date(startDate.getTime() + DAY_DURATION * (i * 7 + 1)))\n          };\n        }\n      }\n\n      for (var j = 0; j < 7; j++) {\n        // columns\n        var cell = row[showWeekNumber ? j + 1 : j];\n\n        if (!cell) {\n          row[showWeekNumber ? j + 1 : j] = {\n            row: i,\n            column: j,\n            type: 'normal',\n            inRange: false,\n            start: false,\n            end: false\n          };\n          cell = row[showWeekNumber ? j + 1 : j];\n        }\n\n        cell.type = 'normal';\n        var index = i * 7 + j; //current date offset\n\n        var time = startDate.getTime() + DAY_DURATION * index;\n        cell.inRange = time >= clearHours(minDate) && time <= clearHours(maxDate);\n        cell.start = minDate && time === clearHours(minDate);\n        cell.end = maxDate && time === clearHours(maxDate);\n        var isToday = time === now;\n\n        if (isToday) {\n          cell.type = 'today';\n        }\n\n        if (i === 0) {\n          //handle first row of date, this row only contains all or some pre-month dates\n          if (j >= offsetDaysToWeekOrigin) {\n            cell.text = count++;\n\n            if (count === 2) {\n              firstDayPosition = i * 7 + j;\n            }\n          } else {\n            cell.text = dateCountOfLastMonth - offsetDaysToWeekOrigin + j + 1;\n            cell.type = 'prev-month';\n          }\n        } else {\n          if (count <= dateCountOfMonth) {\n            //in current dates\n            cell.text = count++;\n\n            if (count === 2) {\n              firstDayPosition = i * 7 + j;\n            }\n          } else {\n            // next month\n            cell.text = count++ - dateCountOfMonth;\n            cell.type = 'next-month';\n          }\n        }\n\n        cell.disabled = isFunction(disabledDate) && disabledDate(new Date(time), SELECTION_MODES.DAY);\n      }\n\n      if (selectionMode === SELECTION_MODES.WEEK) {\n        var start = showWeekNumber ? 1 : 0;\n        var end = showWeekNumber ? 7 : 6;\n        var isWeekActive = this.isWeekActive(row[start + 1]);\n        row[start].inRange = isWeekActive;\n        row[start].start = isWeekActive;\n        row[end].inRange = isWeekActive;\n        row[end].end = isWeekActive;\n        row.isWeekActive = isWeekActive;\n      }\n    }\n\n    rows.firstDayPosition = firstDayPosition;\n    return rows;\n  }; // calc classnames for cell\n\n\n  DateTable.prototype.getCellClasses = function getCellClasses(cell) {\n    var _props2 = this.props,\n        selectionMode = _props2.selectionMode,\n        date = _props2.date;\n    var classes = [];\n\n    if ((cell.type === 'normal' || cell.type === 'today') && !cell.disabled) {\n      classes.push('available');\n\n      if (cell.type === 'today') {\n        classes.push('today');\n      }\n    } else {\n      classes.push(cell.type);\n    }\n\n    if (selectionMode === 'day' && (cell.type === 'normal' || cell.type === 'today') // following code only highlight date that is the actuall value of the datepicker, but actually it should\n    // be the temp that value use selected\n    && date.getDate() === +cell.text) {\n      // && value\n      // && value.getFullYear() === date.getFullYear()\n      // && value.getMonth() === date.getMonth()\n      // && value.getDate() === Number(cell.text)) {\n      classes.push('current');\n    }\n\n    if (cell.inRange && (cell.type === 'normal' || cell.type === 'today' || selectionMode === 'week')) {\n      classes.push('in-range');\n\n      if (cell.start) {\n        classes.push('start-date');\n      }\n\n      if (cell.end) {\n        classes.push('end-date');\n      }\n    }\n\n    if (cell.disabled) {\n      classes.push('disabled');\n    }\n\n    return classes.join(' ');\n  };\n\n  DateTable.prototype.getMarkedRangeRows = function getMarkedRangeRows() {\n    var _props3 = this.props,\n        showWeekNumber = _props3.showWeekNumber,\n        minDate = _props3.minDate,\n        selectionMode = _props3.selectionMode,\n        rangeState = _props3.rangeState;\n    var rows = this.getRows();\n    if (!(selectionMode === SELECTION_MODES.RANGE && rangeState.selecting && rangeState.endDate instanceof Date)) return rows;\n    var maxDate = rangeState.endDate;\n\n    for (var i = 0, k = rows.length; i < k; i++) {\n      var row = rows[i];\n\n      for (var j = 0, l = row.length; j < l; j++) {\n        if (showWeekNumber && j === 0) continue;\n        var cell = row[j];\n        var index = i * 7 + j + (showWeekNumber ? -1 : 0);\n        var time = this.getStartDate().getTime() + DAY_DURATION * index;\n        cell.inRange = minDate && time >= clearHours(minDate) && time <= clearHours(maxDate);\n        cell.start = minDate && time === clearHours(minDate.getTime());\n        cell.end = maxDate && time === clearHours(maxDate.getTime());\n      }\n    }\n\n    return rows;\n  };\n\n  DateTable.prototype.isWeekActive = function isWeekActive(cell) {\n    if (this.props.selectionMode !== SELECTION_MODES.WEEK) return false;\n    if (!this.props.value) return false;\n    var newDate = new Date(this.props.date.getTime()); // date view\n\n    var year = newDate.getFullYear();\n    var month = newDate.getMonth();\n\n    if (cell.type === 'prev-month') {\n      newDate.setMonth(month === 0 ? 11 : month - 1);\n      newDate.setFullYear(month === 0 ? year - 1 : year);\n    }\n\n    if (cell.type === 'next-month') {\n      newDate.setMonth(month === 11 ? 0 : month + 1);\n      newDate.setFullYear(month === 11 ? year + 1 : year);\n    }\n\n    newDate.setDate(parseInt(cell.text, 10));\n    return getWeekNumber(newDate) === deconstructDate(this.props.value).week; // current date value\n  };\n\n  DateTable.prototype.handleMouseMove = function handleMouseMove(event) {\n    var _this2 = this;\n\n    var _props4 = this.props,\n        showWeekNumber = _props4.showWeekNumber,\n        onChangeRange = _props4.onChangeRange,\n        rangeState = _props4.rangeState,\n        selectionMode = _props4.selectionMode;\n\n    var getDateOfCell = function getDateOfCell(row, column, showWeekNumber) {\n      var startDate = _this2.getStartDate();\n\n      return new Date(startDate.getTime() + (row * 7 + (column - (showWeekNumber ? 1 : 0))) * DAY_DURATION);\n    };\n\n    if (!(selectionMode === SELECTION_MODES.RANGE && rangeState.selecting)) return;\n    var target = event.target;\n    if (target.tagName !== 'TD') return;\n    var column = target.cellIndex;\n    var row = target.parentNode.rowIndex - 1;\n    rangeState.endDate = getDateOfCell(row, column, showWeekNumber);\n    onChangeRange(rangeState);\n  };\n\n  DateTable.prototype.handleClick = function handleClick(event) {\n    var target = event.target;\n    if (target.tagName !== 'TD') return;\n    if (hasClass(target, 'disabled') || hasClass(target, 'week')) return;\n    var _props5 = this.props,\n        selectionMode = _props5.selectionMode,\n        date = _props5.date,\n        onPick = _props5.onPick,\n        minDate = _props5.minDate,\n        maxDate = _props5.maxDate,\n        rangeState = _props5.rangeState;\n\n    var _deconstructDate = deconstructDate(date),\n        year = _deconstructDate.year,\n        month = _deconstructDate.month;\n\n    if (selectionMode === 'week') {\n      target = target.parentNode.cells[1];\n    }\n\n    var cellIndex = target.cellIndex;\n    var rowIndex = target.parentNode.rowIndex - 1;\n    var cell = this.getRows()[rowIndex][cellIndex];\n    var text = cell.text;\n    var className = target.className;\n    var newDate = new Date(year, month, 1);\n\n    if (className.indexOf('prev') !== -1) {\n      if (month === 0) {\n        newDate.setFullYear(year - 1);\n        newDate.setMonth(11);\n      } else {\n        newDate.setMonth(month - 1);\n      }\n    } else if (className.indexOf('next') !== -1) {\n      if (month === 11) {\n        newDate.setFullYear(year + 1);\n        newDate.setMonth(0);\n      } else {\n        newDate.setMonth(month + 1);\n      }\n    }\n\n    newDate.setDate(parseInt(text, 10));\n\n    if (selectionMode === SELECTION_MODES.RANGE) {\n      if (rangeState.selecting) {\n        if (newDate < minDate) {\n          rangeState.selecting = true;\n          onPick({\n            minDate: toDate(newDate),\n            maxDate: null\n          }, false);\n        } else if (newDate >= minDate) {\n          rangeState.selecting = false;\n          onPick({\n            minDate: minDate,\n            maxDate: toDate(newDate)\n          }, true);\n        }\n      } else {\n        if (minDate && maxDate || !minDate) {\n          // be careful about the rangeState & onPick order\n          // since rangeState is a object, mutate it will make child DateTable see the\n          // changes, but wont trigger a DateTable re-render. but onPick would trigger it.\n          // so a reversed order may cause a bug.\n          rangeState.selecting = true;\n          onPick({\n            minDate: toDate(newDate),\n            maxDate: null\n          }, false);\n        }\n      }\n    } else if (selectionMode === SELECTION_MODES.DAY || selectionMode === SELECTION_MODES.WEEK) {\n      onPick({\n        date: newDate\n      });\n    }\n  };\n\n  DateTable.prototype.render = function render() {\n    var _this3 = this;\n\n    var $t = Locale.t;\n    var _props6 = this.props,\n        selectionMode = _props6.selectionMode,\n        showWeekNumber = _props6.showWeekNumber;\n    return React.createElement('table', {\n      cellSpacing: '0',\n      cellPadding: '0',\n      onClick: this.handleClick.bind(this),\n      onMouseMove: this.handleMouseMove.bind(this),\n      className: this.classNames('el-date-table', {\n        'is-week-mode': selectionMode === 'week'\n      })\n    }, React.createElement('tbody', null, React.createElement('tr', null, showWeekNumber && React.createElement('th', null, $t('el.datepicker.week')), this.WEEKS().map(function (e, idx) {\n      return React.createElement('th', {\n        key: idx\n      }, $t('el.datepicker.weeks.' + e));\n    })), this.getMarkedRangeRows().map(function (row, idx) {\n      return React.createElement('tr', {\n        key: idx,\n        className: _this3.classNames('el-date-table__row', {\n          'current': row.isWeekActive\n        })\n      }, row.map(function (cell, idx) {\n        return React.createElement('td', {\n          className: _this3.getCellClasses(cell),\n          key: idx\n        }, cell.type === 'today' ? $t('el.datepicker.today') : cell.text);\n      }));\n    })));\n  };\n\n  return DateTable;\n}(Component);\n\nexport default DateTable;\nDateTable.propTypes = {\n  disabledDate: PropTypes.func,\n  showWeekNumber: PropTypes.bool,\n  //minDate, maxDate: only valid in range mode. control date's start, end info\n  minDate: PropTypes.instanceOf(Date),\n  maxDate: PropTypes.instanceOf(Date),\n  selectionMode: PropTypes.oneOf(Object.keys(SELECTION_MODES).map(function (e) {\n    return SELECTION_MODES[e];\n  })),\n  // date view model, all visual view derive from this info\n  date: PropTypes.instanceOf(Date).isRequired,\n  // current date value, use picked.\n  value: PropTypes.instanceOf(Date),\n\n  /*\n  (data, closePannel: boolean)=>()\n     data:\n      if selectionMode = range: // notify when ranges is change\n        minDate: Date|null,\n        maxDate: Date|null\n       if selectionMode = date\n        date: Date\n       if selectionMode = week:\n        year: number\n        week: number,\n        value: string,\n        date: Date\n  */\n  onPick: PropTypes.func.isRequired,\n\n  /*\n  ({\n    endDate: Date,\n    selecting: boolean,\n  })=>()\n  */\n  onChangeRange: PropTypes.func,\n  rangeState: PropTypes.shape({\n    endDate: PropTypes.date,\n    selecting: PropTypes.bool\n  }),\n  firstDayOfWeek: PropTypes.range(0, 6)\n};\nDateTable.defaultProps = {\n  selectionMode: 'day',\n  firstDayOfWeek: 0\n};","map":null,"metadata":{},"sourceType":"module"}